# -*- coding: utf-8 -*-
"""MIMO_dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16B6k1O98he-_FycmoTJ7l94KsJY_ZHxR
"""

!pip install --pre deepmimo

import numpy as np
import deepmimo as dm

scenario = 'city_10_austin_3p5'
dm.download(scenario)
dataset = dm.load(scenario)

params = dm.ChannelParameters()
params.bs_antenna.shape = [8, 1]
params.ue_antenna.shape = [4,1]
channels = dataset.compute_channels(params)

H1 = np.array(dataset.channels[0])
np.save("deepmimo_channels1.npy", H1)

Hs = np.squeeze(H1, axis=-1)           # remove subcarrier dimension -> (34935, 4, 8)
print("H shape:", Hs.shape)

num_samples, Nr, Nt = Hs.shape
snr_db = 20  # example SNR (dB)
snr_linear = 10 ** (snr_db / 10)

def qpsk_symbols(n):
    bits = np.random.randint(0, 2, (n, 2))
    symbols = (2*bits[:,0]-1) + 1j*(2*bits[:,1]-1)
    symbols /= np.sqrt(2)  # normalize power
    return symbols

# Generate transmit matrix X: (num_samples, Nt)
X = np.array([qpsk_symbols(Nt) for _ in range(num_samples)])  # shape (num_samples, Nt)
print("X shape:", X.shape)

# Allocate Y
Y = np.zeros((num_samples, Nr), dtype=np.complex64)

for i in range(num_samples):
    H = Hs[i]            # (Nr, Nt)
    x = X[i][:, None]    # (Nt, 1)
    y = H @ x            # (Nr, 1)
    Y[i] = y.flatten()

# Add complex Gaussian noise
noise_power = np.mean(np.abs(Y)**2) / snr_linear
noise = np.sqrt(noise_power/2) * (np.random.randn(*Y.shape) + 1j*np.random.randn(*Y.shape))
Y_noisy = Y + noise

Hs.astype(np.float32).tofile("H.bin")
X.astype(np.float32).tofile("X.bin")
Y_noisy.astype(np.float32).tofile("Y.bin")

data = np.load("mimo_detection_dataset.bin")
print("H:", data["H"].shape)
print("X:", data["X"].shape)
print("Y:", data["Y"].shape)